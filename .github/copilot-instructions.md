# Life-Simulator AI Quickstart

- Use `aftman install` to pull `rojo@7.5.1`; run `rojo serve default.project.json` while iterating and `rojo build default.project.json -o build.rbxm` for exports. Lint with `selene src` (std is set to `roblox`).
- `default.project.json` maps `src/Server` into `ServerScriptService.Server`, `src/Client` into `StarterPlayerScripts.Client`, `src/Shared` and `src/Network` into `ReplicatedStorage`, and `ServerPackages` into `ServerStorage.ServerPackages`.
- Server bootstrap lives in `src/Server/Main.server.luau`; it wires `PlotService`, `BuildService`, `ResidentService`, and `ResidentAutonomyService`. Keep that init order: residents must unload before plots are unclaimed in `OnPlayerRemoving`.
- Persistent state flows through `Server/Services/PlayerSession` which wraps the custom `ServerPackages/DataStore` module. Call `PlayerSession.GetDataAwait(player, category)` for blocking access; prefer `TryGetData` for non-blocking probes.
- Plots: `PlotService` claims tagged models from `PlotFinder`, instantiates a `PlotState` (chunk size 5) per player, hydrates from `PlayerSession` data, and mirrors placement into the world via `WorldPlacer`. Any new placement logic must update both the runtime `PlotState.Save.PlacedObjects` map and broadcast a `PlacementPackets.PlacementDelta` so clients stay in sync.
- `PlotState` (see `src/Server/Classes/PlotState`) owns all grid math: cell reservation, walls, floors, roofs, rotations, and movement helpers. Always use its APIs (`Place`, `PlaceWall`, `MoveCellObject`, etc.) instead of mutating `Save` directly; it normalizes placement keys with `PlacementKey`.
- Building actions are centralized in `BuildService`. It guards remotes with `RateLimiter` (`place` bucket = 4/sec burst 6) and handles type-specific cases (door replacements via `ReplaceWallSegment`, floors/roofs enforcing `HasFloorUnderFootprint`, station registration with `PlotService.AddStationForPlayer`). When adding new placement types, mirror the server branches in the client preview modules.
- Client state lives in `Client/ClientStores/PlotStateStore`: it consumes `PlacementPackets.PlotStateSync` to seed local snapshots and listens to `PlacementDelta` to mutate a local map keyed by `PlacementKey`. Any new server packet should emit deltas in the same shape (`{ Action = "Placed"|"Removed", Item = { ItemId, CellX, CellZ, Facing } }`).
- Network remotes are defined via `Packages/Packet`; use the declarative shape in `src/Network/*.luau` and require the packet module on both sides. Remember that `Packet:Fire` expects typed payloads that match the schema and enforces response timeouts.
- NPCs: `ResidentService` loads household saves, instantiates `ResidentState` objects (with an `ActionQueue`), and spawns models through `ResidentPlacer` into each plot’s `Residents` folder. Adding new resident actions usually means extending `ResidentState` plus `Client/UserInterface` menus, and broadcasting changes through `ResidentsPackets`.
- Catalog definitions live under `src/Shared/Definitions/Catalog`. Each item must provide `ModelPath` under `ReplicatedStorage.Assets.Catalog`, optional `StationType`, footprint sizes, and rule flags (`RequiresFloorUnderAllCells`, `RequiresExistingWall`). `ItemFinder` merges all tables at require-time, so keep IDs unique.
- `WorldPlacer` expects every plot model to expose a `Container` folder (for placed items), a `Residents` folder, `Surface` part (with `CellSize` attribute), and optional `Covers` folder for fog-of-war parts. When adding art assets, update those hierarchies so placement stays aligned (uses `Grid:FootprintCenterCFrame`).
- Collision and physics: both server and client force player characters into the `Players` collision group (`Main.server.luau` and `Main.client.luau`). Maintain that when customizing character handling.
- Rate limiting / security: keep all authoritative checks server-side—clients only preview. Mirror validation rules (floors under items, adjacency for chunk unlocks) in UI for UX, but never rely on them for enforcement.
- Testing a placement change: claim a plot, place an item, rotate, move, destroy, and verify `PlotStateStore` updates plus `PlotService.PlayerStations` cache (for station-type items). Watch for door moves, which use the `moveDoorSegment` helper and expect metadata (`previousWallId`).
- Before saving data-sensitive changes, ensure `PlotService.Load` still spawns starter chunks (defaults to `{ cx = 1, cz = 3 }`) and that `NameToIndexMap` in `ResidentService` stays consistent after insert/delete.
- All Luau files opt into `--!strict`; keep annotations (`Facing`, `PlotRuntimeState`, etc.) accurate to avoid Selene/Luau type errors.
