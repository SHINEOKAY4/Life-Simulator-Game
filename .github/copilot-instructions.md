# Life-Simulator AI Guide

- **Tooling** Run `aftman install` to pull `rojo@7.5.1`; iterate with `rojo serve default.project.json`, export via `rojo build default.project.json -o build.rbxm`, and lint with `selene src` (std = `roblox`).
- **Rojo map** `default.project.json` routes `src/Server`→`ServerScriptService.Server`, `src/Client`→`StarterPlayerScripts.Client`, `src/Shared`+`src/Network`→`ReplicatedStorage`, and `ServerPackages`→`ServerStorage.ServerPackages`.
- **Server bootstrap** `src/Server/Main.server.luau` wires `ResidentService.Init()` → `PlotService.Init()` → `BuildService.Init()` → `ResidentAutonomyService.Init()` → `DirectActionService.Init()` → `ResidentNeedService.Init()`. Preserve this order so `OnPlayerRemoving` can unload residents before plots.
- **Persistence** `Server/Services/PlayerSession` wraps `ServerPackages/DataStore`; use `GetDataAwait(player, "Category")` for blocking loads, `TryGetData` for probes, and respect the retry timeout before assuming failure.
- **Plot claiming** `PlotService.Claim` tags the plot model (`ReplicatedStorage.Shared.Utilities.PlotFinder`), hydrates a `PlotState` with chunk size 5, and mirrors save data into the 3D world through `WorldPlacer.Spawn`.
- **Starter chunks** `PlotService.Load` auto-injects `{ cx = 1, cz = 3 }` into `UnlockedChunks` when the profile is empty—keep that fallback when changing persistence schemas.
- **Runtime state** Always mutate plots through `PlotState` methods (`Place`, `PlaceWall`, `MoveCellObject`, `UnlockChunk`, etc.). Keys are normalized with `PlacementKey`, and the same keys feed station caches and client snapshots.
- **Station cache** When placing or removing catalog items with `StationType`, call `PlotService.AddStationForPlayer` / `RemoveStationForPlayer`. Autonomy relies on `PlayerStations` and `StationScopeVersions` to locate usable stations.
- **World placement** `WorldPlacer` expects each plot model to expose `Container`, `Residents`, `Surface` (with `CellSize`), and optional `Covers`. Models cloned via `ItemFinder.CloneModel` are named with their placement key and anchored; door installs reuse `PreviousWallId` metadata.
- **Network packets** Define remotes via `Packages/Packet` (`src/Network/*.luau`). Server handlers return `(boolean, message)` pairs, and deltas must match the schema—`PlacementPackets.PlacementDelta` broadcasts `{ Action, ItemId, CellX, CellZ, Facing }`.
- **Client sync** `Client/ClientStores/PlotStateStore` receives `PlotStateSync` to rebuild local state, then tails `PlacementDelta` and `PlotStateUnlockDelta` for incremental updates. Keep payloads consistent or snapshots desynchronize.
- **BuildService guards** `BuildService` shares a single rate limiter (`place` bucket = 4/sec, burst 6) across place/move/destroy/rotate. Floors/roofs validate `HasFloorUnderFootprint`, walls use `ReplaceWallSegment`, and door moves go through `moveDoorSegment` which expects persisted `previousWallId` metadata.
- **Move/rotate bookkeeping** On station-bearing items, moves/rotations must call `PlotService.RemoveStationForPlayer`/`AddStationForPlayer` with the old/new placement keys to keep station occupancy coherent.
- **Chunk unlocking** `PlotService.UnlockArea` requires adjacency and broadcasts `PlotStateUnlockDelta` with chunk indices; client gating mirrors this but server remains authoritative.
- **Resident lifecycle** `ResidentService` loads `HouseholdState.Residents`, spawns models via `ResidentPlacer`, and maintains `NameToIndexMap`. Always rebuild indices after table mutations or deletions break persistence ordering.
- **Automation loop** `ResidentAutonomyService` schedules via `WorldUpdate.Subscribe`, evaluating needs every second. It consults `NeedConfig`, `TimeScale`, and the station cache to queue behaviors through `DirectActionService` handlers—new needs require matching station handlers and catalog items.
- **Direct actions** Manual UI requests and autonomy share handler modules in `Server/Modules/ResidentActionHandlers`; ensure new behavior exposes both an action handler and any chat text/need effects expected by `NeedEffects` and `ResidentChat`.
- **Movement helpers** Use `ResidentMovement.GoToWorldPosition` and `WorldPlacer` utilities instead of manual CFrame math; they respect grid origin, chunk bounds, and door fillers.
- **Collision group** Both `Main.server.luau` and `Main.client.luau` force player character parts into the `Players` collision group—maintain this when customizing character pipelines.
- **Catalog data** Item definitions live under `src/Shared/Definitions/Catalog`. Provide `ModelPath`, footprint, allowed facings, rule flags, and optional `StationType`/`maxOccupancy`. `ItemFinder` merges all tables at require time; duplicate IDs conflict silently.
- **Selene & types** All Luau files run `--!strict`; keep type aliases (`Facing`, `PlotRuntimeState`, `ResidentData`) in sync with implementation to avoid Selene and typechecker errors.
- **Testing loop** After placement code changes, claim a plot, place/move/rotate/destroy items, watch `PlotStateStore` and `PlayerStations` updates, and verify residents still route to stations (especially door moves and roofs that gate `RequiresFloorUnderAllCells`).

Let me know if any section needs deeper examples or if something about the data flow is unclear.
